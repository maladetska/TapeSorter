# TapeSorter

### How to build and start?

Config example:
```
$ cat <CONFIG_DIR>/config.cfg
N = 19
M = 65
delay_for_read = 0
delay_for_put = 0
delay_for_shift = 0
path_in = <PATH_TO_INPUT_TAPE>
path_out = <PATH_TO_OUTPUT_TAPE>
```

Commands:
```
$ git clone 'https://github.com/maladetska/TapeSorter'
$ cd TapeSorter
$ cmake CMakeLists.txt
$ make
$ ./bin/TapeSorter <CONFIG_DIR>/config.cfg
```


### Идея:
Условимся, что внешней памятью будем считать файлы, в которых лежат ленты ( $Tape$ ). 
Если $M <= N$ или $M$ не сильно превышает занчение $N$ , тогда лента полностью может не поместиться во внутреннюю память, поэтому будем делить ленту на "куски" ( $chunk$ ) и работать во внутренней памяти только с одним куском. Уже с кусками работать удобнее и памяти должно хватить, если правильно рассчитать количество таких кусков ( $count_of_chunks_$ ) и их размеры ( $max_size_chunk_$ и $last_size_chunk_$ ) (об этом позже).

Итак, чтобы отсортировать ленту, нужно в первую очередь разделить её полностью на ленты. Размер одной ленты и одного куска будут совпадать, то прямо во внутренней памяти отсортируем ( $std::sort$ ) ленты (то есть куски) и положим их во внешнюю память.(1) Полученных лент будет $count_of_chunks_$ ; размер всех, кроме последней, - $max_size_chunk_$ ; размер последней - $last_size_chunk_$ или $max_size_chunk_$ . Теперь будем попарным слиянием лент получать ленты бОльшего размера(2), пока не получим одну отсортированную ленту, которую поместим в ленту-ответ.

Как же определиться с размером одного куска? Внутренняя память нужна для сортировки ленты-куска(1) и для слияние далее полученных лент(2). 
- Во внутренней памяти есть $M$ свободных байт;
- Размер числа на ленте не превышает 4 байта ( $int32_t$ -> 32 бита);
Для первого случая учтём, что:
- $std::sort$ работает за $n$ памяти;
- пусть размер куска $$chunk_size$$;
- внутреннюю память надо выделить на кусок ( $chunk_size$ ), $std::sort$ ( $chunk_size$ ) и на отсортированный кусок ( $chunk_size$ ), а так же оставить на хранения некоторых перемнных и выполнение некоторых операций (пусть тоже $chunk_size$ );
- нам понадрбится $4 * chunk_size$.
Для второго случая учтём, что:
- пусть размер куска $chunk_size$;
- внутреннюю память надо выделить на два куска, которые мы будем слиять ($chunk_size$ + $chunk_size$) и на кусок новой ленты, который будем заполнять ($chunk_size$), а так же оставить на хранения некоторых перемнных и выполнение некоторых операций (пусть тоже $chunk_size$);
- нам понадрбится $4 * chunk_size$.

Итак, в двух случаях нам надо выделить $4 * chunk_size == M / 4$ => $chunk_size == M / 16$


### Возможная оптимизация, мысль о которой пришла поздно:
Из-за особенностей работы с файлами в C++, для реализации метода $put$ (записать число в нынешнюю позицию) приходится тратить больше ресурсов, чем хотелось бы. Однако, если входной файл был бы бинарным, где внутри лежали int32_t, можно было бы менять одно значение на другое в нынешней ячейке ленты очень просто и быстро, ведь размер файла не поменяется, а у каждого числа размер одинаковый: 32 бита.
 




